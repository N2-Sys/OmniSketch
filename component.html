<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OmniSketch: Main components</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OmniSketch
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Oh my sketch!</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('component.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Main components </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#configparser">Config Parser</a><ul><li class="level2"><a href="#openconfig">Open the Config File</a></li>
<li class="level2"><a href="#parseatroot">Parse Root Table</a></li>
<li class="level2"><a href="#switchtable">Switch to a New Table</a></li>
<li class="level2"><a href="#closeconfigparser">Close Config Parser</a></li>
<li class="level2"><a href="#reminderpcapparser">Reminder</a></li>
</ul>
</li>
<li class="level1"><a href="#dataformat">Data Format</a><ul><li class="level2"><a href="#syntaxdataformat">Syntax</a></li>
<li class="level2"><a href="#getdataformat">Read Data Format</a></li>
</ul>
</li>
<li class="level1"><a href="#streamdata">Stream Data</a><ul><li class="level2"><a href="#readstreamdata">Read Stream Data</a></li>
<li class="level2"><a href="#iteratorstreamdata">Iterators</a></li>
</ul>
</li>
<li class="level1"><a href="#gndtruth">Ground Truth</a><ul><li class="level2"><a href="#iteratorgndtruth">Iterators</a></li>
<li class="level2"><a href="#estimate">Estimation</a></li>
</ul>
</li>
<li class="level1"><a href="#sketchntest">Sketch &amp; Test</a><ul><li class="level2"><a href="#overrideruntest">Override runTest()</a></li>
<li class="level2"><a href="#trailingcomment">Trailing Comment</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Congratulations! Now you have had a solid understanding of <a class="el" href="namespace_omni_sketch.html">OmniSketch</a>'s foundations. To further our knowledge, we turn to the main components of <a class="el" href="namespace_omni_sketch.html">OmniSketch</a>. They are the workhorses you must master!</p>
<h1><a class="anchor" id="configparser"></a>
Config Parser</h1>
<p>One of the initial questions that may spring to your mind is how to parse the config file. In <a class="el" href="namespace_omni_sketch.html">OmniSketch</a>, since many configurations are structured data, like a vector or a table, we choose <a href="https://toml.io/en/">toml</a> to be the config language. The link points to a brief tutorial on the toml language and we parse the <code>.toml</code> file via a C++ repo, <a href="https://marzer.github.io/tomlplusplus/">tomlplusplus</a>. It is one of the submodules you fetched via <code>git clone --recurse-submodules</code> when cloning this framework!</p>
<p>Our Config Parser wraps around tomlplusplus by providing a file-system-like interface called <a class="el" href="class_omni_sketch_1_1_util_1_1_config_parser.html">ConfigParser</a>. Path to the root table of a toml file is always an empty string <code>""</code>, and this is the default place where an opened Config Parser is located. To parse a piece of information within a table, you first have to invoke <a class="el" href="class_omni_sketch_1_1_util_1_1_config_parser.html#a7bc9a0341c81199ed989c6c2a0d2f3e4">setWorkingNode()</a> for the parser to step into that table, and then calls <a class="el" href="class_omni_sketch_1_1_util_1_1_config_parser.html#a177f9985c7765d0538b81487830ebd52">parseConfig()</a> on the argument you want to parse. Since the table can nest in toml, a path is always a <code>.</code>-concatenated string from the root to the destination table. (So in terms of a file system, there is only absolute path!) Let us figure it out via an example. Suppose we have a toml file <code>example.toml</code> in the <code>build/</code> (the directory where you should run your sketch).</p>
<div class="fragment"><div class="line"># example.toml</div>
<div class="line"> </div>
<div class="line"># root table</div>
<div class="line">name = &quot;OmniSketch&quot;</div>
<div class="line">fibonacci = [1, 1, 2, 3, 5, 8]</div>
<div class="line"> </div>
<div class="line"># table</div>
<div class="line">[tutorial]</div>
<div class="line">name = &quot;Sketch&quot;</div>
<div class="line"> </div>
<div class="line">  # nested table</div>
<div class="line">  [tutorial.component]</div>
<div class="line">  fibonacci = true</div>
</div><!-- fragment --><h2><a class="anchor" id="openconfig"></a>
Open the Config File</h2>
<p>To open the config file, you should provide a path to it and then check the opening status. The following lines of code are typically seen in every sketch test file. See <a href="https://github.com/N2-Sys/OmniSketch/blob/main/src/sketch_test/BloomFilterTest.h#L73">the testing class of the Bloom Filter</a> for instance.</p>
<div class="fragment"><div class="line"><span class="comment">// In function `void runTest(void)`</span></div>
<div class="line"><span class="comment">// using namespace OmniSketch::Util;</span></div>
<div class="line">ConfigParser parser(<span class="stringliteral">&quot;example.toml&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(!parser.succeed()){</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="parseatroot"></a>
Parse Root Table</h2>
<p>Now the parser is at the root table. If you have <code>std::string name</code> and <code>std::vector&lt;int32_t&gt; fib</code> defined, you can parse with</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(!parser.parseConfig(name, <span class="stringliteral">&quot;name&quot;</span>)){</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span>(!parser.parseConfig(fib, <span class="stringliteral">&quot;fibonacci&quot;</span>){</div>
<div class="line">  return;</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you are aware, the first argument holds a reference to a runtime variable, while the second gives the key name in the config table.</p>
<h2><a class="anchor" id="switchtable"></a>
Switch to a New Table</h2>
<p>Let us continue to parse <code>name</code> in the table <code>tutorial</code>. This can be done in two lines.</p>
<div class="fragment"><div class="line">parser.setWorkingNode(<span class="stringliteral">&quot;tutorial&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(!parser.parseConfig(name, <span class="stringliteral">&quot;name&quot;</span>)){</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// assert(name == &quot;Sketch&quot;);</span></div>
</div><!-- fragment --><p>Note that the content of <code>name</code> is no longer <code>"OmniSketch"</code>, but <code>"Sketch"</code>! Continuing our journey, now we are to parse the innermost <code>fibonacci</code>, which is a boolean variable. Suppose we have <code>bool var</code> defined.</p>
<div class="fragment"><div class="line">parser.setWorkingNode(<span class="stringliteral">&quot;tutorial.component&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(!parser.parseConfig(var, <span class="stringliteral">&quot;fibonacci&quot;</span>)){</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// assert(var == true);</span></div>
</div><!-- fragment --><p>If you want to go back to the root table again, call <code>parser.setWorkingNode("")</code>.</p>
<h2><a class="anchor" id="closeconfigparser"></a>
Close Config Parser</h2>
<p>Indeed, you do not have to bother with the closing issue. Config Parser will free its resources once it is destroyed.</p>
<h2><a class="anchor" id="reminderpcapparser"></a>
Reminder</h2>
<p>You have the feeling of mastering Config Parser, don't you? But before we proceed to the next topic, here a few reminders.</p>
<ul>
<li>Toml is only capable of recording limited types of data directly, so is <a class="el" href="class_omni_sketch_1_1_util_1_1_config_parser.html#a177f9985c7765d0538b81487830ebd52">parseConfig()</a>. Here is a list of all supported data types, you will find them sufficient in virtually all cases.<ul>
<li><code>int32_t</code></li>
<li><code>size_t</code></li>
<li><code>double</code></li>
<li><code>bool</code></li>
<li><code>std::string</code></li>
<li><code>std::vector&lt;int32_t&gt;</code></li>
<li><code>std::vector&lt;size_t&gt;</code></li>
<li><code>std::vector&lt;double&gt;</code></li>
<li><code>std::vector&lt;std::string&gt;</code></li>
<li><code>toml::array</code> <blockquote class="doxtable">
<p>But it does <em>NOT</em> mean that any type other than these cannot be parsed. Take a \(M\times N\) matrix for example. In <a class="el" href="namespace_omni_sketch.html">OmniSketch</a>, you can parse it with a <code>toml::array</code>, which represents an object containing \(M\) inner <code>toml::array</code>, which in turn contains \(N\) elements each. From the returning <code>toml::array</code>, you may call underlying API documented in <a href="https://marzer.github.io/tomlplusplus/">tomlplusplus</a> to get the matrix elements one by one. </p>
</blockquote>
</li>
</ul>
</li>
<li>Again, we emphasize that all paths in Config Parser are absolute (i.e., start from the root) and are interspersed with dots (<code>.</code>), not slash (<code>/</code>) or backslash (<code>\</code>) as are in a usual file system.</li>
<li>On a parsing error, a descriptive message will be logged, so just return to end the function if in case it does happen. This is how all previous codes do.</li>
</ul>
<h1><a class="anchor" id="dataformat"></a>
Data Format</h1>
<p>Data format controls the output format of pcapparser and the way <a class="el" href="namespace_omni_sketch.html">OmniSketch</a> interpreting the input binary file. It specifies which fields are in a packet record, the length of each field, and the order in which they are deserialized. A valid data format runs as follows. It is excerpted from <a href="https://github.com/N2-Sys/OmniSketch/blob/main/src/sketch_config.toml">sketch_config.toml</a>. </p><div class="fragment"><div class="line">format = [[&quot;flowkey&quot;, &quot;padding&quot;, &quot;timestamp&quot;, &quot;length&quot;, &quot;padding&quot;],</div>
<div class="line">          [13,        3,         8,           2,        6]]</div>
</div><!-- fragment --><p>It says that each packet record in <code>.bin</code> takes \(13+3+8+2+6=32\) bytes, with the first 13 bytes being the flowkey, then following a 3-byte padding and so on. Its semantics is quite straightforward, isn't it?</p>
<h2><a class="anchor" id="syntaxdataformat"></a>
Syntax</h2>
<p>You may be wondering the determining rule of a valid data format expression in toml, and it is what we now touch upon. Though a context-free grammar (Yup, a context-sensitive grammar overpowers here. This is a mild exercise in automata theory.) suffices to express this rule, we find this description rather tricky and tedious, so we recede to a description in natural language here.</p>
<p>There are four distinct fields. Some have their length contained, while some have further constraints on their occurence. All these restrictions are summarized in this table. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field Name </th><th class="markdownTableHeadLeft">Viable Length </th><th class="markdownTableHeadLeft">Further Constraints  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">flowkey </td><td class="markdownTableBodyLeft">4, 8, 13 </td><td class="markdownTableBodyLeft">Specify exactly once  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">timestamp </td><td class="markdownTableBodyLeft">1, 2, 4, 8 </td><td class="markdownTableBodyLeft">In microseconds. Specify at most once  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">length </td><td class="markdownTableBodyLeft">1, 2, 4, 8 </td><td class="markdownTableBodyLeft">Specify at most once  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">padding </td><td class="markdownTableBodyLeft">&gt; 0 </td><td class="markdownTableBodyLeft">None  </td></tr>
</table>
<p>In fact, any data format not violating any of these rules is valid. You can check the preceding example that it is indeed valid. Here are a few more examples to help you consolidate your understanding.</p>
<div class="fragment"><div class="line">[[&quot;timestamp&quot;, &quot;length&quot;], [2, 4]] # Invalid, no `flowkey` is specified</div>
<div class="line">[[&quot;padding&quot;, &quot;flowkey&quot;], [0, 12]] # Invalid, `padding` length should &gt; 0; `flowkey` cannot be 12 bytes</div>
<div class="line">[[&quot;flowkey&quot;], [4]] # Valid, the simplest data format</div>
<div class="line">[[&quot;flowkey&quot;, 4]] # Invalid, brackets mismatch</div>
<div class="line">[[&quot;timestamp&quot;, &quot;flowkey&quot;, &quot;padding&quot;, &quot;timestamp&quot;], [4, 8, 1, 4]] # Invalid, `timestamp` occurs twice</div>
</div><!-- fragment --><h2><a class="anchor" id="getdataformat"></a>
Read Data Format</h2>
<p>But how you get this data format? Well, as you may have noticed, <code>toml::array</code> is a parsable type of <a class="el" href="component.html#reminderpcapparser">Config Parser</a>. On the other hand, <a class="el" href="class_omni_sketch_1_1_data_1_1_data_format.html">DataFormat</a> should be constructed with just a <code>toml::array</code>. This is not a coincidence!</p>
<p>Let again look into <a href="https://github.com/N2-Sys/OmniSketch/blob/main/src/sketch_test/BloomFilterTest.h#L89">the testing class of the Bloom Filter</a>. You see these lines.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!parser.parseConfig(arr, <span class="stringliteral">&quot;format&quot;</span>))</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">Data::DataFormat format(arr);</div>
</div><!-- fragment --><p>It searches for a key named <code>format</code> in the current toml table and return a <code>toml::array</code> object. Later, it is used to construct a <a class="el" href="class_omni_sketch_1_1_data_1_1_data_format.html">DataFormat</a> object. Shortly we will see how this <a class="el" href="class_omni_sketch_1_1_data_1_1_data_format.html">DataFormat</a> object is used: It is passed to a <a class="el" href="class_omni_sketch_1_1_data_1_1_stream_data.html">StreamData</a> object to parse the input data.</p>
<h1><a class="anchor" id="streamdata"></a>
Stream Data</h1>
<p>A runtime container is needed to hold the packet records, and this job is delegated to <a class="el" href="class_omni_sketch_1_1_data_1_1_stream_data.html">StreamData</a>. All <a class="el" href="namespace_omni_sketch.html">OmniSketch</a> knows about the data come from this class.</p>
<h2><a class="anchor" id="readstreamdata"></a>
Read Stream Data</h2>
<p>As with <a class="el" href="component.html#configparser">Config Parser</a> and <a class="el" href="component.html#dataformat">Data Format</a>, reading is done upon constructing a class instance. You should give two arguments to the constructor: first a path to the <code>.bin</code> file, followed by a corresponding <a class="el" href="component.html#dataformat">Data Format</a>. You should check the reading status with the <a class="el" href="class_omni_sketch_1_1_data_1_1_stream_data.html#a84e00b67fcac89ae5e90b3cef5623798">succeed()</a> method.</p>
<blockquote class="doxtable">
<p>Make sure <code>key_len</code> in template header and the <code>flowkey</code> length in config file match. Otherwise, a runtime exception would be thrown. </p>
</blockquote>
<h2><a class="anchor" id="iteratorstreamdata"></a>
Iterators</h2>
<p>Conceptually speaking, streaming data is nothing but a sequence of packets, so it is no wonder that <a class="el" href="class_omni_sketch_1_1_data_1_1_stream_data.html">StreamData</a> supports random-access iterator. Moreover, the interface of getting an iterator out of this class resembles that of STL. There you fetch the size via <a class="el" href="class_omni_sketch_1_1_data_1_1_stream_data.html#ac29c3bd32c709b3382662ae713dc4a2b">size()</a>, get a beginning or endding iterator via <a class="el" href="class_omni_sketch_1_1_data_1_1_stream_data.html#a98600c09ad55ac6603ab9b5958fac821">begin()</a> and <a class="el" href="class_omni_sketch_1_1_data_1_1_stream_data.html#a47fd80f14e8ca1fc992a56f04aeb7bee">end()</a>. In case that you would love to access a record in between, make a call to <a class="el" href="class_omni_sketch_1_1_data_1_1_stream_data.html#a94d28bdd79c4cd25b476a9a501e89645">diff()</a>.</p>
<p>Two such iterators \(\langle p,q\rangle\), with proper order, represents a range of data \([p,q)\). Note that the range is left-included and right-excluded. This chunk of data is always what your sketch are to dispose of.</p>
<h1><a class="anchor" id="gndtruth"></a>
Ground Truth</h1>
<p>Most <a class="el" href="overview.html#metrics">metrics</a> compare the result of a query to sketch with the ground truth. That is basically why you have to maintain the real-world answer from time to time. Luckily, in <a class="el" href="namespace_omni_sketch.html">OmniSketch</a> this is done by the class <a class="el" href="class_omni_sketch_1_1_data_1_1_gnd_truth.html">GndTruth</a>. It has two template parameters, first the length of flowkey and then a counter type. Throughout the project, we encourage the practice of explicitising length of every built-in numeric type, like <code>int32_t</code> in lieu of <code>int</code>, <code>uint64_t</code> in lieu of <code>unsigned long long</code>.</p>
<p>GndTruth is a bidirectional map between flowkey and its value. That is, you can not only query a flowkey for its value, but a value for all the corresponding flowkeys. It starts with a default constructor, and after that you should call its method to fill its content from yet another <a class="el" href="class_omni_sketch_1_1_data_1_1_gnd_truth.html">GndTruth</a> or <a class="el" href="class_omni_sketch_1_1_data_1_1_stream_data.html">StreamData</a> instance. Again, <a href="https://github.com/N2-Sys/OmniSketch/blob/main/src/sketch_test/BloomFilterTest.h#L129">the testing class of the Bloom Filter</a> for inspiration. You may notice that in <a class="el" href="namespace_omni_sketch.html">OmniSketch</a> there are two methods for counting: <code>InPacket</code> and <code>InLength</code>. Difference is easy to tell: <code>InPacket</code> counts each packet, regardless of its length, as 1; Yet <code>InLength</code> counts its length.</p>
<h2><a class="anchor" id="iteratorgndtruth"></a>
Iterators</h2>
<p>Since <a class="el" href="class_omni_sketch_1_1_data_1_1_gnd_truth.html">GndTruth</a> is in essence a bidirectional map, its iterator must differ from that of <a class="el" href="class_omni_sketch_1_1_data_1_1_stream_data.html">StreamData</a> a bit. Any iterator stemmed from this class points to a bidirectional key-value pair: one for flowkey (accessible with the method <code>get_left()</code> or the member <code>second</code>), the other for the value (accessible with the method <code>get_right()</code> or the member <code>first</code>).</p>
<p>What's more, the iterator is random-access. This feature greatly facilitates an efficient implementation of <a class="el" href="namespace_omni_sketch.html">OmniSketch</a>, but you are not likely to encounter such a use case when you design new sketch.</p>
<h2><a class="anchor" id="estimate"></a>
Estimation</h2>
<p>When it comes to heavy hitters and heavy changers, your sketch may output a list of candidates, each being a key-value pair. Though occasionally your sketch may not be able to predict the value of a flowkey, you may just fill in the value with all 0.</p>
<p><a class="el" href="class_omni_sketch_1_1_data_1_1_estimation.html">Estimation</a> is just another wrapper around <a class="el" href="class_omni_sketch_1_1_data_1_1_gnd_truth.html">GndTruth</a>, and the available interfaces are hugely changed. It provides you with several insertion methods and should be the returning type for <a class="el" href="class_omni_sketch_1_1_sketch_1_1_sketch_base.html#ab8dec0e0d4382016225dbd75788f3ff9">getHeavyHitter()</a> or <a class="el" href="class_omni_sketch_1_1_sketch_1_1_sketch_base.html#aadc2b3b7792938931e86a80c6c7b5fe6">getHeavyChanger()</a>. Follow the link to docs whenever necessary.</p>
<h1><a class="anchor" id="sketchntest"></a>
Sketch &amp; Test</h1>
<p>Finally we have arrive at a place where sketch is implemented and tested. You see that all sketches reside in the directory <code>src/sketch</code>. In order for the testing class to find the methods in base sketch, we take a quintessential object-oriented method, derivation. Your sketch should be subclass of <a class="el" href="class_omni_sketch_1_1_sketch_1_1_sketch_base.html">SketchBase</a>, and any method overriden should be declared with a <code>override</code> specifier. See the detailed description of <a class="el" href="class_omni_sketch_1_1_sketch_1_1_sketch_base.html">SketchBase</a> for a complete instruction on how to do this. Besides, you are encouraged to take a look at the current sketches and mimic their way of coding.</p>
<p>The sketch, on its design, had better have as its template parameters the length of flowkey, type of hashing class and counter type. But a non-template implementation works just fine. Here is a template file provided for your convenience.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hash_8h.html">common/hash.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sketch_8h.html">common/sketch.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespace_omni_sketch_1_1_sketch.html">OmniSketch::Sketch</a> {</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span>32_t key_len, <span class="keyword">typename</span> T, <span class="keyword">typename</span> hash_t = Hash::AwareHash&gt;</div>
<div class="line"><span class="keyword">class </span>[SKETCH] : <span class="keyword">public</span> SketchBase&lt;key_len, T&gt; {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">  [SKETCH_CONSTRUCTOR]</div>
<div class="line">  [SKETCH_DESTRUCTOR]</div>
<div class="line"> </div>
<div class="line">  [OVERRIDEN_METHODS]</div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">   * void update(const FlowKey&lt;key_len&gt; &amp;flowkey, T val) override;</span></div>
<div class="line"><span class="comment">   * T query(const FlowKey&lt;key_len&gt; &amp;flowkey) const override;</span></div>
<div class="line"><span class="comment">   * size_t size() const override;</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line"> </div>
<div class="line">  [OTHER_METHODS]</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace OmniSketch::Sketch</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//-----------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                        Implementation of templated methods</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//-----------------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespace_omni_sketch_1_1_sketch.html">OmniSketch::Sketch</a> {</div>
<div class="line">...</div>
<div class="line">} <span class="comment">// namespace OmniSketch::Sketch</span></div>
</div><!-- fragment --><p>The testing side follows the same rationale. All your testing classes should be derived from <a class="el" href="class_omni_sketch_1_1_test_1_1_test_base.html">TestBase</a>, which defines test routines using the pointer to <a class="el" href="class_omni_sketch_1_1_sketch_1_1_sketch_base.html">SketchBase</a>. The main task in subclass is to override the <a class="el" href="class_omni_sketch_1_1_test_1_1_test_base.html#a8f69ecdc1770170421fafb5b4c418d3d">runTest()</a> method just as in <a href="https://github.com/N2-Sys/OmniSketch/blob/main/src/sketch_test/BloomFilterTest.h">BloomFilterTest</a>. Here is a template file provided for your convenience. You may be curious about how to override <a class="el" href="class_omni_sketch_1_1_test_1_1_test_base.html#a8f69ecdc1770170421fafb5b4c418d3d">runTest()</a> and what the last three mysterious lines do. Shortly we will explain it.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="test_8h.html">common/test.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sketch/[SKETCH_FILENAME]&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespace_omni_sketch_1_1_test.html">OmniSketch::Test</a> {</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span>32_t key_len, <span class="keyword">typename</span> hash_t = Hash::AwareHash&gt;</div>
<div class="line"><span class="keyword">class </span>[SKETCH_TEST] : <span class="keyword">public</span> TestBase&lt;key_len&gt; {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  [CONSTRUCTOR]</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> runTest() <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace OmniSketch::Test</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//-----------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                        Implementation of templated methods</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//-----------------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespace_omni_sketch_1_1_test.html">OmniSketch::Test</a> {</div>
<div class="line">...</div>
<div class="line">} <span class="comment">// namespace OmniSketch::Test</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Driver instance:</span></div>
<div class="line"><span class="comment">//      AUTHOR: [AUTHOR]</span></div>
<div class="line"><span class="comment">//      CONFIG: [DEFAULT_CONFIG]  # with respect to the `src/` directory</span></div>
<div class="line"><span class="comment">//    TEMPLATE: [TEMPLATE_HEADER]</span></div>
</div><!-- fragment --><h2><a class="anchor" id="overrideruntest"></a>
Override runTest()</h2>
<p>Now let us expand our mastery of testing. What should we do in <a class="el" href="class_omni_sketch_1_1_test_1_1_test_base.html#a8f69ecdc1770170421fafb5b4c418d3d">runTest()</a>? Well, there is no panacea, because "a thousand sketches have a thousand testing methods", but basically we will do the following sequentially.</p>
<ol type="1">
<li>Parse the configurations via <a class="el" href="component.html#configparser">Config Parser</a>.</li>
<li>Allocate one or several sketch instances with the parsed configurations as the constructing arguments and downcast the pointer(s) to <code>SketchBase&lt;key_len&gt; *</code>. It is even more robust if you create a <code>unique_ptr&lt;SketchBase&lt;key_len&gt;&gt;</code> object.</li>
<li>Use the data format parsed and path to input data to read in streaming data via <a class="el" href="component.html#streamdata">Stream Data</a>.</li>
<li>Data should be used at your discretion. On the one hand, they are fed into the sketch via overriden method. On the other hand, <a class="el" href="component.html#gndtruth">Ground Truth</a> scans through the data to help you get the ground truth value.</li>
<li>Note that we do not have to call the overriden methods in sketch directly. All the methods <code>testXXX()</code> in <code>TestBase</code> call them de facto. With a method name called <code>testXXX()</code>, we supply a key named <code>XXX</code> in the config file to indicate which metrics to collect. The following table shows which metrics can be collected in the corresponding testing methods.</li>
</ol>
<table class="doxtable">
<tr>
<td><b>Test Routine</b> </td><td><b>Required Overriden Function</b> </td><td><b>Available Metrics (In Test::Metric)</b> </td><td><b>Name of the Testing Routine in TOML</b>  </td></tr>
<tr>
<td>testSize() </td><td>size() </td><td>SIZE </td><td><em>None</em> (Once calling testSize(), the metric is collected)   </td></tr>
<tr>
<td>testInsert() </td><td>insert() </td><td>RATE </td><td><code>insert</code>  </td></tr>
<tr>
<td>testUpdate() </td><td>update() </td><td>RATE </td><td><code>update</code>  </td></tr>
<tr>
<td>testQuery() </td><td>query() </td><td>RATE, ARE, AAE, ACC, PODF, DIST </td><td><code>query</code>  </td></tr>
<tr>
<td>testLookup() </td><td>lookup() </td><td>RATE, TP, FP, PRC </td><td><code>lookup</code>  </td></tr>
<tr>
<td>testHeavyHitter() </td><td>getHeavyHitter() </td><td>TIME, ARE, PRC, RCL, F1 </td><td><code>heavyhitter</code>  </td></tr>
<tr>
<td>testHeavyChanger() </td><td>getHeavyChanger()  </td><td>TIME, ARE, PRC, RCL, F1 </td><td><code>heavychanger</code>  </td></tr>
<tr>
<td>testDecode() </td><td>decode() </td><td>TIME, RATIO, ARE, AAE, ACC, PODF, DIST </td><td><code>decode</code>  </td></tr>
</table>
<blockquote class="doxtable">
<p>The rule of thumb is that if you are not sure what to do next, feel free to refer to existing sketch tests! </p>
</blockquote>
<h2><a class="anchor" id="trailingcomment"></a>
Trailing Comment</h2>
<p>It is suggested that both sketch and test are templated, so how to generate a ready-to-be-compiled driver?</p>
<p>The driver has to some minimal task: It looks for <code>-c</code> option from terminal to change the default config file, and then allocates a sketch test instance and invoke its overriden <code>runTest()</code> method. This process is so mechanic that we provide a python script <code>src/generate_driver.py</code> to do such job.</p>
<p>You never have to run this python script manually. Indeed, the command <code>add_user_sketch</code> in cmake is specially customized so that each time you <code>make</code> (not <code>cmake</code>) the project, if the sketch file or test file should be changed, a new driver is automatically compiled and linked for you, using the name from <code>add_user_sketch</code>.</p>
<p>How does <code>generate_driver.py</code> know what driver you want to generate? Now trailing comment in the last three lines kicks into play. Technically speaking, three pieces of information should be provided: author's name (after <code>AUTHOR:</code>), default configuration file for this test class (after <code>CONFIG:</code>), plus a template header with arguments bracketed inside a <code>&lt;&gt;</code> (after <code>TEMPLATE:</code>).</p>
<p>The order of these lines are uninterested. What matters is that they appear on the last three distinct lines, beginning with a line comment or inside a block comment. If the test class is not templated you leave the space after <code>TEMPLATE:</code> empty. To convince yourself of the exact rule of writing trailing comment, you read through the python script. Nevertheless, the safest and worthiest way is to copy comment from existing testing files and modify it slightly. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespace_omni_sketch_1_1_test_html"><div class="ttname"><a href="namespace_omni_sketch_1_1_test.html">OmniSketch::Test</a></div><div class="ttdoc">Testing classes and metrics.</div><div class="ttdef"><b>Definition:</b> test.h:23</div></div>
<div class="ttc" id="asketch_8h_html"><div class="ttname"><a href="sketch_8h.html">sketch.h</a></div><div class="ttdoc">Base sketch.</div></div>
<div class="ttc" id="anamespace_omni_sketch_1_1_sketch_html"><div class="ttname"><a href="namespace_omni_sketch_1_1_sketch.html">OmniSketch::Sketch</a></div><div class="ttdoc">Implementation of templated methods.</div><div class="ttdef"><b>Definition:</b> hierarchy.h:19</div></div>
<div class="ttc" id="atest_8h_html"><div class="ttname"><a href="test_8h.html">test.h</a></div><div class="ttdoc">Testing classes and metrics.</div></div>
<div class="ttc" id="ahash_8h_html"><div class="ttname"><a href="hash_8h.html">hash.h</a></div><div class="ttdoc">Warehouse of hashing classes.</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
